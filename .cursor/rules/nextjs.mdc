---
description:
globs:
alwaysApply: true
---
---
description: This rule provides comprehensive guidance for Next.js development..
---
# Next.js Best Practices

This document outlines best practices for developing Next.js applications, focusing on code organization, performance optimization, security, testing strategies, and common pitfalls to avoid. Adhering to these guidelines will help you build robust, scalable, and maintainable applications.

## 1. Code Organization

### File Naming Conventions

*   **Components:** `component.name.jsx` or `component.name.tsx`
*   **Pages:** `page.ts`, `page.tsx` (within the `app` or `pages` directory)
*   **Layouts:** `layout.ts`, `layout.tsx` (within the `app` directory)
*   **API Routes:** `route.ts` (within the `app/api` directory or `pages/api` directory)
*   **Hooks:**  `use.hook.name.ts`
*   **Styles:** `component.name.module.css` or `component.name.module.scss`
*   **Types:** `types.ts` or `interfaces.ts`

### Module Organization

*   **Co-location:** Keep related components, styles, and tests in the same directory.
*   **Design**: atomic design
*   **Avoid deeply nested directories:** Keep the directory structure relatively flat to improve navigation.

### Component Architecture

*   **Presentational vs. Container Components:** Separate components that handle data fetching and state management (container components) from those that only render UI (presentational components).
*   **Atomic Design:** Organize components into atoms, molecules, organisms, templates, and pages for better reusability and maintainability.
*   **Composition over inheritance:** Favor composition to create flexible and reusable components.
*   **Server Components (app directory):**  Use server components by default for improved performance.  Only use client components when interactivity (event handlers, useState, useEffect) is required.

### Code Splitting

*   **Dynamic imports:** Use `next/dynamic` to load components only when they are needed, improving initial load time.  Example: `dynamic(() => import('../components/MyComponent'))`.
*   **Route-level code splitting:** Next.js automatically splits code based on routes, so each page only loads the necessary JavaScript.
*   **Granular code splitting:** Break down large components into smaller chunks that can be loaded independently.

## 2. Common Patterns and Anti-patterns

### Design Patterns

*   **Higher-Order Components (HOCs):** Reusable component logic.
*   **Render Props:** Sharing code between React components using a prop whose value is a function.
*   **Hooks:** Extracting stateful logic into reusable functions.
*   **Context API:** Managing global state.
*   **Compound Components:** Combining multiple components that work together implicitly.

### Recommended Approaches

*   **Data fetching:** Use `React Query` for client-side data fetching and caching.
*   **Styling:** Use CSS Modules, Styled Components, or Tailwind CSS for component-level styling.  Prefer Tailwind CSS for rapid development.
*   **State Management:** Use React Context, Zustand, Jotai, or Recoil for managing global state.  Redux is an option, but often overkill for smaller Next.js projects.
*   **Form Handling:** Use `react-hook-form` for managing forms and validation.
*   **API Routes:** Use Next.js API routes for serverless functions.

### Anti-patterns and Code Smells

*   **Over-fetching data:** Only fetch the data that is needed by the component.
*   **Blocking the main thread:** Avoid long-running synchronous operations in the main thread.
*   **Mutating state directly:** Always use `setState` or hooks to update state.
*   **Not memoizing components:** Use `React.memo` to prevent unnecessary re-renders.
*   **Using `useEffect` without a dependency array:** Ensure the dependency array is complete to prevent unexpected behavior.
*   **Writing server side code in client components:** Can expose secrets or cause unexpected behavior.

### State Management

*   **Local State:** Use `useState` for component-specific state.
*   **Context API:** Use `useContext` for application-wide state that doesn't change often.
*   **Third-party libraries:** Use `Zustand`, `Jotai`, or `Recoil` for more complex state management needs. These are simpler and more performant alternatives to Redux for many Next.js use cases.

### Error Handling

*   **`try...catch`:** Use `try...catch` blocks for handling errors in asynchronous operations.
*   **Custom Error Pages:** Use `_error.js` or `_error.tsx` to create custom error pages.
*   **Route-level error handling (app directory):** Use `error.tsx` within route segments to handle errors specific to that route.

## 3. Performance Considerations

### Optimization Techniques

*   **Image optimization:** Use `next/image` component for automatic image optimization, including lazy loading and responsive images.
*   **Font optimization:**  Use `next/font` to optimize font loading and prevent layout shift.
*   **Code splitting:** Use dynamic imports and route-level code splitting to reduce initial load time.
*   **Caching:** Use caching strategies (e.g., `Cache-Control` headers, `React Query`) to reduce data fetching overhead.
*   **Memoization:** Use `React.memo` to prevent unnecessary re-renders of components.
*   **Prefetching:** Use the `<Link prefetch>` tag to prefetch pages that are likely to be visited.
*   **SSR/SSG:** Use Static Site Generation (SSG) for content that doesn't change often and Server-Side Rendering (SSR) for dynamic content.
*   **Incremental Static Regeneration (ISR):** Use ISR to update statically generated pages on a regular interval.

### Memory Management

*   **Avoid memory leaks:** Clean up event listeners and timers in `useEffect` hooks.
*   **Minimize re-renders:** Only update state when necessary to reduce the number of re-renders.
*   **Use immutable data structures:** Avoid mutating data directly to prevent unexpected side effects.

### Rendering Optimization

*   **Server Components (app directory):**  Render as much as possible on the server to reduce client-side JavaScript.
*   **Client Components (app directory):** Only use client components when interactivity is required. Defer rendering of non-critical client components using `React.lazy`.

### Bundle Size Optimization

*   **Remove unused code:** Use tree shaking to remove unused code from your bundles.
*   **Use smaller dependencies:** Replace large dependencies with smaller, more lightweight alternatives.
*   **Compression:** Enable Gzip or Brotli compression on your server to reduce the size of the transferred files.

### Lazy Loading

*   **Images:** Use `next/image` for automatic lazy loading of images.
*   **Components:** Use `next/dynamic` for lazy loading of components.
*   **Intersection Observer:** Use the Intersection Observer API for manual lazy loading of content.

## 4. Security Best Practices

### Common Vulnerabilities

*   **Cross-Site Scripting (XSS):** Sanitize user input to prevent XSS attacks.  Be especially careful when rendering HTML directly from user input.
*   **Cross-Site Request Forgery (CSRF):** Use CSRF tokens to protect against CSRF attacks.
*   **SQL Injection:** Use parameterized queries or an ORM to prevent SQL injection attacks.
*   **Authentication and Authorization vulnerabilities:** Implement secure authentication and authorization mechanisms.  Avoid storing secrets in client-side code.
*   **Exposing sensitive data:** Protect API keys and other sensitive data by storing them in environment variables and accessing them on the server-side.

### Input Validation

*   **Server-side validation:** Always validate user input on the server-side.
*   **Client-side validation:** Use client-side validation for immediate feedback, but don't rely on it for security.
*   **Sanitize input:** Sanitize user input to remove potentially malicious code.
*   **Use a validation library:** Use a library like `zod` for validating user input.

### Authentication and Authorization

*   **Use a secure authentication provider:** Use a service like Auth0, NextAuth.js, or Firebase Authentication for secure authentication.
*   **Store tokens securely:** Store tokens in HTTP-only cookies or local storage.
*   **Implement role-based access control:** Use role-based access control to restrict access to sensitive resources.
*   **Protect API endpoints:** Use authentication middleware to protect API endpoints.

### Data Protection

*   **Encrypt sensitive data:** Encrypt sensitive data at rest and in transit.
*   **Use HTTPS:** Use HTTPS to encrypt communication between the client and the server.
*   **Regularly update dependencies:** Keep your dependencies up to date to patch security vulnerabilities.
*   **Secure environment variables:**  Never commit environment variables to your repository.  Use a secrets management tool if necessary.

### Secure API Communication

*   **Use HTTPS:** Use HTTPS for all API communication.
*   **Authenticate API requests:** Use API keys or tokens to authenticate API requests.
*   **Rate limiting:** Implement rate limiting to prevent abuse of your API.
*   **Input validation:** Validate all API request parameters.
*   **Output encoding:** Properly encode API responses to prevent injection attacks.

## 6. Common Pitfalls and Gotchas

### Version-Specific Issues

*   **Breaking changes:** Be aware of breaking changes when upgrading Next.js versions.
*   **Deprecated features:** Avoid using deprecated features.
*   **Compatibility with third-party libraries:** Ensure that third-party libraries are compatible with the Next.js version being used.

### Compatibility Concerns

*   **Browser compatibility:** Ensure that the application is compatible with the target browsers.
*   **Third-party library compatibility:** Ensure that third-party libraries are compatible with Next.js.

### Debugging Strategies

*   **Use the browser developer tools:** Use the browser developer tools to inspect the DOM, debug JavaScript, and analyze network requests.
*   **Use console.log statements:** Use `console.log` statements to debug code.
*   **Use a debugger:** Use a debugger to step through code and inspect variables.
*   **Use error logging:** Log errors to a central service to track and analyze issues.